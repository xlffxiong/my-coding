
运行原理：
原理：jenkins上的执行器是通过rancher管理，运行在多个虚拟机上, 所以可以通过登录rancher进入执行器操作
参考以下
https://blog.csdn.net/weixin_47055136/article/details/132067384?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-132067384-blog-105292756.235%5Ev40%5Epc_relevant_3m_sort_dl_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-132067384-blog-105292756.235%5Ev40%5Epc_relevant_3m_sort_dl_base2&utm_relevant_index=4

大概是这个
```
Rancher 是一个开源的容器管理平台，它可以用来部署和管理容器化的应用程序。Jenkins 是一个开源的自动化服务器，用于自动化软件开发的构建、测试和部署。

如果你想要使用 Rancher 来管理 Jenkins 上的执行器（也就是 Jenkins 的 agent 或者 slave），你可以通过在 Rancher 上部署 Jenkins 的执行器作为容器来实现。以下是一个基本的步骤指南：

准备 Jenkins 主服务器：
确保你的 Jenkins 主服务器已经运行，并且可以从 Rancher 管理的集群中访问。

创建 Jenkins 执行器的 Docker 镜像：
你可以使用 Jenkins 官方提供的 jnlp-slave 镜像，或者根据需要自定义一个 Dockerfile 来创建你自己的 Jenkins 执行器镜像。

在 Rancher 上部署 Jenkins 执行器：
在 Rancher 的界面中，你可以创建一个新的工作负载来部署 Jenkins 执行器容器。你需要确保执行器容器可以与 Jenkins 主服务器通信，并且配置适当的环境变量，如 JENKINS_URL（Jenkins 主服务器的 URL）、JENKINS_SECRET（执行器的连接密钥）和 JENKINS_AGENT_NAME（执行器的名称）。

配置 Jenkins 主服务器：
在 Jenkins 主服务器上，你需要配置一个新的节点，并选择 "Launch agent via Java Web Start"（通过 Java Web Start 启动代理）。在节点配置中，你需要输入在 Rancher 部署的执行器容器的相关信息。

启动执行器并连接到 Jenkins：
当 Rancher 部署的 Jenkins 执行器容器启动时，它会尝试连接到 Jenkins 主服务器。如果配置正确，它将会作为一个节点出现在 Jenkins 的节点列表中，并可以接受任务并执行构建。
```

https://blog.csdn.net/g950904/article/details/109753953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-12-109753953-blog-132067384.235^v40^pc_relevant_3m_sort_dl_base2&spm=1001.2101.3001.4242.7&utm_relevant_index=15

stage('Prepare Env')
1、分配执行机
  执行机本质是rancher管理的虚拟机
日志： running on xxx in {jenkins服务器代码目录}，注意代码目录固定
2、环境准备
  2.1 清理之前的allure报告
  2.2 清理之前的录像和截图
  2.3 清理之前的代码（每次均需要重新拉取最新代码）
  2.4 是否延迟构建
3、代码准备
  3.1 jenkins配置和github的凭证，使用该凭证拉取用例代码，
  3.2 删除一些linux不能用的依赖  sed -i s#pywin32##g requirements.txt
  3.3 依赖相关使用pip拉取或卸载 
      卸载已存在的，安装最新的   
    sh "python3.10 -m pip uninstall -y pp-scp sd-scp docker docker-py"
    sh "python3.10 -m pip install pymysql"
    sh "python3.10 -m pip install -r requirements.txt"
  3.4 若存在多个代码分支，如e-cloud 和epoch
    1）可以选择基于3.1安装依赖
    2）重新拉取新项目，再次安装依赖
stage('Test Run')
4、运行pytest
  4.1 删除缓存文件 rm -rf /home/jenkins/workspace/NG_PyTest_Py3/pytest_cache.tar.gz
  4.2 构建pytest 运行tag,如  (mark_level__bvt or mark_level__level1 or mark_level__level2 or mark_level__level3) and (mark_status__stable and mark_layer__system) and (mark_tl__tl2)
(mark_level__bvt or mark_level__level1 or mark_level__level2 or mark_level__level3) and (mark_status__stable and mark_layer__system) and (mark_tl__tl2)
  4.3 运行 
   python3.10 -m pytest e-cloud/am/cases/ske/platform_feature/privilege -m (mark_level__bvt or mark_level__level1 or mark_level__level2 or mark_level__level3) and (mark_status__stable and mark_layer__system) and (mark_tl__tl2) -s -v 
--reruns 0 --show-capture=stderr --durations=30 --alluredir /var/reportCacheHub/QA-TestCI/NG_PyTest_Py3/25506/rspec_reports --collect-only
    此时可以判断是否有按照失败的缓存文件构建的用例，如果存在，按照缓存构建，否则按照正常构建
post {
      always {
    4.4 archiveArtifacts 保存产物 'pytest_cache.tar.gz'
      ```
      archiveArtifacts 是一个在持续集成/持续部署（CI/CD）中常用的术语，特别是在 Jenkins 这类自动化服务器中。它指的是在构建过程结束后，将生成的构建产物（如编译后的二进制文件、日志文件、测试报告等）保存起来的操作。
      
      在 Jenkins 中，archiveArtifacts 是一个步骤（step），可以在 Jenkinsfile（Jenkins 的管道配置文件）中使用，用于指定哪些文件或目录应该被归档和保存。这样做的目的是为了保留构建的历史记录，以便将来可以回溯和分析
      ```
  }
    aborted {
        sh'pkill -2 python'
        sh 'release env'
        sh 'recover source'
    }
  fail
  https://github.com/jenkinsci/allure-plugin/issues/163
部署流程参考这个
https://blog.51cto.com/zhangxueliang/8767156
https://blog.csdn.net/g950904/article/details/109753953?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-12-109753953-blog-132067384.235^v40^pc_relevant_3m_sort_dl_base2&spm=1001.2101.3001.4242.7&utm_relevant_index=15
https://blog.csdn.net/weixin_47055136/article/details/132067384?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-132067384-blog-105292756.235%5Ev40%5Epc_relevant_3m_sort_dl_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-132067384-blog-105292756.235%5Ev40%5Epc_relevant_3m_sort_dl_base2&utm_relevant_index=4



  UI创建容器
docker run -d -P --name=xxx_chrome_debug --privileged=true --user=root -e VNC_NO_PASSWORD=1 -e SCREEN_WIDTH=1920 -e SCREEN_HEIGHT=1080 -e SE_OPTS='-sessionTimeout 7200' -v /sf/dir_ci/salmon/images/:/var/salmon_images -v /sf/dir_ci/salmon/mount:/tmp/salmon_mount -v /tmp/chrome_downloads:/home/seluser/Downloads --shm-size=256MB standalone-chrome-salmon
=================
UI使用的镜像是  https://hub.docker.com/r/selenium/standalone-chrome
docker run：Docker 的命令，用于运行一个新的容器。
-d：以分离模式运行容器，即在后台运行。
-P：将容器的所有端口映射到主机。
--name=xxx_chrome_debug：设置容器的名称为 xxx_chrome_debug。
--privileged=true：以特权模式运行容器。
--user=root：以 root 用户身份运行容器。
-e VNC_NO_PASSWORD=1：设置环境变量 VNC_NO_PASSWORD 的值为 1。
-e SCREEN_WIDTH=1920 -e SCREEN_HEIGHT=1080：设置环境变量 SCREEN_WIDTH 和 SCREEN_HEIGHT 的值，分别为 1920 和 1080，这可能是用于设置 VNC 服务的屏幕分辨率。
-e SE_OPTS='-sessionTimeout 7200'：设置环境变量 SE_OPTS 的值为 -sessionTimeout 7200，这是用于设置 Selenium 服务器的会话超时时间，单位是秒。
-v /sf/dir_ci/salmon/images/:/var/salmon_images：将主机的 /sf/dir_ci/salmon/images/ 目录挂载到容器的 /var/salmon_images 目录。
-v /sf/dir_ci/salmon/mount:/tmp/salmon_mount：将主机的 /sf/dir_ci/salmon/mount 目录挂载到容器的 /tmp/salmon_mount 目录。
-v /tmp/chrome_downloads:/home/seluser/Downloads：将主机的 /tmp/chrome_downloads 目录挂载到容器的 /home/seluser/Downloads 目录。
--shm-size=256MB：设置容器的共享内存大小为 256MB。
standalone-chrome-salmon：要运行的 Docker 镜像的名称。
这条命令的主要目的是运行一个名为 standalone-chrome-salmon 的 Docker 镜像，并进行一些特定的设置，如设置环境变量、挂载目录、设置共享
